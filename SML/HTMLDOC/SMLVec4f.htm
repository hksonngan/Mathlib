<HTML>
<HEAD>
<TITLE>class SMLVec4f</TITLE>
<link href="styles.css" rel="STYLESHEET" type="text/css">
</head>
<BODY LINK="#0000ff" VLINK="#800080">

<P><a NAME="SMLVec4f"></a>[<A href="index.htm">SML Overview</a>]</P>
<H1>class SMLVec4f</h1>
<PRE>#include &quot;<A HREF="smlmath.h">smlmath.h</A>&quot;</PRE>

<P>Class<B> SMLVec4f</B> is a 4x1 vector of single precision floats. It includes data and methods, which allow forming 4-vectors, computing sum, difference, scalar product of two vectors, computing product and quotient of vector and scalar value, finding normalized vector, etc.</P>
<H2>Public Interface</H2>

<h3>Constructors</h3>
<table width=400 cellspacing=5>
<tr>
<TD><P><A HREF="SMLVec4f.htm#constructor">constructors</A></TD>
</tr>
</table>

<h3>Access the data as an array</h3>
<table width=400 cellspacing=5>
<tr>
<TD><P><A HREF="SMLVec4f.htm#data">data</A></TD>
</tr>
</table>

<h3>Rename to XYZW</h3>
<table width=400 cellspacing=5>
<tr>
<TD><P><A HREF="SMLVec4f.htm#X">X</A></TD>
<TD><P><A HREF="SMLVec4f.htm#Y">Y</A></TD>
<TD><P><A HREF="SMLVec4f.htm#Z">Z</A></TD>
</tr>
</table>

<h3>Rename to RGBA</h3>
<table width=400 cellspacing=5>
<tr>
<TD><P><A HREF="SMLVec4f.htm#Red">Red</A></TD>
<TD><P><A HREF="SMLVec4f.htm#Green">Green</A></TD>
<TD><P><A HREF="SMLVec4f.htm#Blue">Blue</A></TD>
</tr>
<tr>
<TD><P><A HREF="SMLVec4f.htm#Alpha">Alpha</A></TD>
</tr>
</table>

<h3>Operators</h3>
<TABLE CELLSPACING=5 WIDTH=600>
<TR>
<TD><P><A HREF="SMLVec4f.htm#operator_equal">operator==</A></TD>
<TD><P><A HREF="SMLVec4f.htm#operator_notequal">operator!=</A></TD>
<TD><P><A HREF="SMLVec4f.htm#operator_less">operator&lt;</A></TD>
</TR>
<TR>
<TD><P><A HREF="SMLVec4f.htm#operator_plus">operator+</A></TD>
<TD><P><A HREF="SMLVec4f.htm#operator_minus">operator-</A></TD>
<TD><P><A HREF="SMLVec4f.htm#operator_plusequal">operator+=</A></TD>
</TR>
<TR>
<TD><P><A HREF="SMLVec4f.htm#operator_minusequal">operator-=</A></TD>
<TD><P><A HREF="SMLVec4f.htm#operator_times">operator*</A></TD>
<TD><P><A HREF="SMLVec4f.htm#operator_divide">operator/</A></TD>
</TR>
<TD><P><A HREF="SMLVec4f.htm#operator_timesequal">operator*=</A></TD>
<TD><P><A HREF="SMLVec4f.htm#operator_divideequal">operator/=</A></TD>
</TABLE>

<h3>Methods</h3>  
<TABLE CELLSPACING=5 WIDTH=600>
<TR>
<TD><P><A HREF="SMLVec3f.htm#Set">Set</A></TD>
<TD><P><A HREF="SMLVec3f.htm#Add">Add</A></TD>
<TD><P><A HREF="SMLVec3f.htm#Sub">Sub</A></TD>
</TR>
<TR>
<TD><P><A HREF="SMLVec3f.htm#Scale">Scale</A></TD>
<TD><P><A HREF="SMLVec3f.htm#ScaleAdd">ScaleAdd</A></TD>
<TD><P><A HREF="SMLVec3f.htm#Dot">Dot</A></TD>
</TR>
<TR>
<TD><P><A HREF="SMLVec4f.htm#Transform">Transform</A></TD>
<TD><P><A HREF="SMLVec4f.htm#Dot">Dot</A></TD>
<TD><P><A HREF="SMLVec4f.htm#Negate">Negate</A></TD>
</TR>
<TR>
<TD><P><A HREF="SMLVec4f.htm#Add">Add</A></TD>
<TD><P><A HREF="SMLVec4f.htm#Sub">Sub</A></TD>
<TD><P><A HREF="SMLVec4f.htm#Scale">Scale</A></TD>
</TR>
<TR>
<TD><P><A HREF="SMLVec4f.htm#Length">Length</A></TD>
<TD><P><A HREF="SMLVec4f.htm#LengthSquared">LengthSquared</A></TD>
<TD><P><A HREF="SMLVec4f.htm#Normalize">Normalize</A></TD>
</TR>
<TR>
<TD><P><A HREF="SMLVec4f.htm#Distance">Distance</A></TD>
<TD><P><A HREF="SMLVec4f.htm#DistanceSquared">DistanceSquared</A></TD>
<TD><P><A HREF="SMLVec4f.htm#operator_assign">operator=</A></TD>
</TR>
</TABLE>

<hr>

<H3>Public Data</H3>
<P>float <B>x</B>;</P>
<P>float <B>y;</P>
</B><P>float <B>z;</P>
</B><P>float <B>w;</P>
</B><P>Defines 4 components of the vector.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P><A NAME="constructor"></A>SMLLIBENTRY <B>SMLVec4f</B>(float <B><I>a</I></B>, float <B><I>b</I></B>, float <B><I>c</I></B>, float <B><I>d</I></B>);</P>
<h4>Discussion</h4>
<P>SMLVec4f object constructor. This constructor sets coordinates of vector equal to <B><I>a, b, c, d </I></B>correspondingly.</P>
<P><I>Example:</I></P>
<PRE><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(3.5f, 0.45f, 1.4f, -2.0f);</PRE>
<h4>Parameters</h4>
<P><B><I>a, b, c, d</I></B> - coordinates of new vector. These parameters should be of float type.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY <B>SMLVec4f</B>(float <B><I>v</I></B>[]);</P>
<h4>Discussion</h4>
<P>SMLVec4f object constructor. The constructor sets the coordinates of vector equal to first four elements of float-type array <B><I>v</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd[4] = {1, 3, 2, 1}; <A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd);</PRE>
<h4>Parameters</h4>
<P><B><I>v</I></B>[] - float-type array with coordinates of new vector. The array must have at least four elements.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY <B>SMLVec4f</B>(const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>v</I></B>);</P>
<h4>Discussion</h4>
<P>SMLVec4f object constructor. The constructor sets coordinates of vector equal to those of vector <B><I>v</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd[4] = {1, 3, 2, 1};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd);<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> B(A);</PRE>
<h4>Parameters</h4>
<P><B><I>v</I></B> - reference to an object of SMLVec4f type. </P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY <B>SMLVec4f</B>();</P>
<h4>Discussion</h4>
<P>Default SMLVec4f object constructor. The constructor sets all coordinates of vector equal to zero.</P>
<P><I>Example:</I></P>
<PRE><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A();</PRE>
<h4>Parameters</h4>
<P>No.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY const float* <A NAME="data"><B>data</B></A>() const;</P>
<P>SMLLIBENTRY float* <B>data</B>(); </P>
<h4>Discussion</h4>
<P>Methods are used for access to component data of the object which are coordinates of a vector.</P>
<P><I>Example:</I></P>
<PRE>float *tmp, crd[4] = {1, 3, 2, 4};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd);<BR>tmp = A.data(); // tmp[1] = 3</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods return float-type pointer to the first element of component data of the object. </P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="X"><B>X</B></A>() const;</P>
<h4>Discussion</h4>
<P>Method is used for access to variable <B><I>x</I></B> of component data of the object. This variable is <B><I>x</I></B>-coordinate of the current vector.</P>
<P><I>Example:</I></P>
<PRE>float tmp, crd[4] = {1, 3, 2, 4};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd);<BR>tmp = A.X(); // tmp = 1</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns value of variable <B><I>x </I></B>of component data of the object.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float&amp; <B>X</B>();</P>
<h4>Discussion</h4>
<P>Method is used as synonym of variable <B><I>x</I></B> of component data of the object.</P>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns reference to variable <B><I>x </I></B>of component data of the object.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="Y"><B>Y</B></A>() const;</P>
<h4>Discussion</h4>
<P>Method is used for access to variable <B><I>y</I></B> of component data of the object. This variable is <B><I>y</I></B>-coordinate of the current vector.</P>
<P><I>Example:</I></P>
<PRE>float tmp, crd[4] = {1, 3, 2, 4};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd);<BR>tmp = A.Y(); // tmp = 3</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns value of variable <B><I>y </I></B>of component data of the object. This variable is <B><I>y</I></B>-coordinate of the current vector.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float&amp; <B>Y</B>();</P>
<h4>Discussion</h4>
<P>Method is used as synonym of variable <B><I>y</I></B> of component data of the object.</P>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns reference to variable <B><I>y</I></B> of component data of the object.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="Z"><B>Z</B></A>() const;</P>
<h4>Discussion</h4>
<P>Method is used for access to variable <B><I>z</I></B> of component data of the object. This variable is <B><I>z</I></B>-coordinate of the current vector.</P>
<P><I>Example:</I></P>
<PRE>float tmp, crd[4] = {1, 3, 2, 4};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd);<BR>tmp = A.Z(); // tmp = 2</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns value of variable <B><I>z </I></B>of component data of the object.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float&amp; <B>Z</B>();</P>
<h4>Discussion</h4>
<P>Method is used as synonym of variable <B><I>z</I></B> of component data of the object.</P>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns reference to variable <B><I>z</I></B> of component data of the object.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float <B>W</B>() const;</P>
<h4>Discussion</h4>
<P>Method is used for access to variable <B><I>w</I></B> of component data of the object. This variable is <B><I>w</I></B>-coordinate of the current vector.</P>
<P><I>Example:</I></P>
<PRE>float tmp, crd[4] = {1, 3, 2, 4};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd);<BR>tmp = A.W(); // tmp = 4</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns value of variable <B><I>w </I></B>of component data of the object.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float&amp; <B>W</B>();</P>
<h4>Discussion</h4>
<P>Method is used as synonym of variable <B><I>w</I></B> of component data of the object.</P>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns reference to variable <B><I>w</I></B> of component data of the object.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="Red"><B>Red</B></A>() const;</P>
<h4>Discussion</h4>
<P>Method is used for access to variable <B><I>x</I></B> of component data of the object. This variable is <B><I>x</I></B>-coordinate of the current vector.</P>
<P><I>Example:</I></P>
<PRE>float tmp, crd[4] = {1, 3, 2, 4};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd);<BR>tmp = A.Red(); // tmp = 1</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns value of variable <B><I>x</I></B> of component data of the object.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float&amp; <B>Red</B>();</P>
<h4>Discussion</h4>
<P>Method is used as synonym of variable <B><I>x</I></B> of component data of the object.</P>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns reference to variable <B><I>x</I></B> of component data of the object.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="Green"><B>Green</B></A>() const;</P>
<h4>Discussion</h4>
<P>Method is used for access to variable <B><I>y</I></B> of component data of the object. This variable is <B><I>y</I></B>-coordinate of the current vector.</P>
<P><I>Example:</I></P>
<PRE>float tmp, crd[4] = {1, 3, 2, 4};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd);<BR>tmp = A.Green(); // tmp = 3</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns value of variable <B><I>y</I></B> of component data of the object.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float&amp; <B>Green</B>();</P>
<h4>Discussion</h4>
<P>Method is used as synonym of variable <B><I>y</I></B> of component data of the object.</P>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns reference to variable <B><I>y</I></B> of component data of the object.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="Blue"><B>Blue</B></A>() const;</P>
<h4>Discussion</h4>
<P>Method is used for access to variable <B><I>z</I></B> of component data of the object. This variable is <B><I>z</I></B>-coordinate of the current vector.</P>
<P><I>Example:</I></P>
<PRE>float tmp, crd[4] = {1, 3, 2, 4};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd);<BR>tmp = A.Blue(); // tmp = 2</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns value of variable <B><I>y</I></B> of component data of the object.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float&amp; <B>Blue</B>();</P>
<h4>Discussion</h4>
<P>Method is used as synonym of variable <B><I>z</I></B> of component data of the object.</P>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns reference to variable <B><I>z</I></B> of component data of the object.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="Alpha"><B>Alpha</B></A>() const;</P>
<h4>Discussion</h4>
<P>Method is used for access to variable <B><I>w</I></B> of component data of the object. This variable is <B><I>w</I></B>-coordinate of the current vector.</P>
<P><I>Example:</I></P>
<PRE>float tmp, crd[4] = {1, 3, 2, 4};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd);<BR>tmp = A.Alpha(); // tmp = 4</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns value of variable <B><I>w</I></B> of component data of the object</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float&amp; <B>Alpha</B>();</P>
<h4>Discussion</h4>
<P>Method is used as synonym of variable <B><I>w</I></B> of component data of the object.</P>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns reference to variable <B><I>w</I></B> of component data of the object.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY const SMLVec4f&amp; <A NAME="operator_assign"><B>operator=</B></A>(const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>v</I></B>);</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It sets coordinates of this vector to those of vector <B><I>v</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd[4] = {1, 3, 2, 4};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd), B;<BR>B = A;</PRE>
<h4>Parameters</h4>
<P><B><I>v -</I></B> reference to object of SMLVec4f type whose coordinates are assigned to the new vector.</P>
<h4>Return Value</h4>
<P>Returns reference to SMLVec4f-type object. </P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>friend SMLLIBENTRY bool <A NAME="operator_less"><B>operator&lt;</B></A>(const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>src</I></B>, const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>v</I></B>);</P>
<h4>Discussion</h4>
<P>Friend of the class. Function compares length of 2 vectors and returns <I>true</I>, if and only if vector <B><I>v1 </I></B>is shorter than <B><I>v2</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd1[4] = {1, 2, 2, 2}, crd2[3] = {2, 2, 2, 2};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd1), B(crd2);<BR>A = (A > B)?A:B // A = B</PRE>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>friend SMLLIBENTRY bool <A NAME="operator_equal"><B>operator==</B></A>(const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>src</I></B>, const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>v</I></B>);</P>
<h4>Discussion</h4>
<P>Friend of the class. Function returns <I>true</I>, if components of two vectors are equal to each other.</P>
<P><I>Example:</I></P>
<PRE>float crd1[4] = {1, 2, 2, 2}, crd2[3] = {2, 2, 2, 2};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd1), B(crd2);<BR>A = (A == B)?A:B // A = B</PRE>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>friend SMLLIBENTRY bool <A NAME="operator_notequal"><B>operator!=</B></A>(const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>src</I></B>, const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>v</I></B>);</P>
<h4>Discussion</h4>
<P>Friend of the class. Function returns <I>true</I>, if components of two vectors are not equal.</P>
<P><I>Example:</I></P>
<PRE>float crd1[4] = {1, 2, 2, 2}, crd2[3] = {2, 2, 2, 2};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd1), B(crd2);<BR>A = (A != B)?A:B // A = B</PRE>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY SMLVec4f <A NAME="operator_plus"><B>operator+</B></A>(const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>v</I></B>) const;</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes and returns sum of two vectors.</P>
<P><I>Example:</I></P>
<PRE>float crd1[4] = {1, 2, 2, 3}, crd2[4] = {2, 2, 2, 3};<BR><A href="SMLVec3f.htm#SMLVec3f">SMLVec3f</A> A(crd1), B(crd2), C;<BR>C = A + B // C = {3, 4, 4, 6}</PRE>
<h4>Parameters</h4>
<P><B><I>v</I></B> - reference to object of SMLVec4f type.</P>
<h4>Return Value</h4>
<P>Returns new object of SMLVec4f type, which is equal to sum of two vectors. </P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY SMLVec4f <A NAME="operator_minus"><B>operator-</B></A>(const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>v</I></B>) const;</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes and returns difference of two vectors.</P>
<P><I>Example:</I></P>
<PRE>float crd1[4] = {1, 2, 2, 3}, crd2[4] = {2, 2, 2, 3};<BR><A href="SMLVec3f.htm#SMLVec3f">SMLVec3f</A> A(crd1), B(crd2), C;<BR>C = A - B // C = {-1, 0, 0, 0}</PRE>
<h4>Parameters</h4>
<P><B><I>v</I></B> - reference to object of SMLVec4f type. </P>
<h4>Return Value</h4>
<P>Returns new object of SMLVec4f type, which is equal to difference of two vectors. </P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY SMLVec3f <A NAME="operator_times"><B>operator*</B></A>(float <B><I>var</I></B>) const;</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes and returns product of vector and variable <B><I>var</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd[4] = {1, 2, 2, 3};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd), C;<BR>C = A * 2.0f // C = {2, 4, 4, 6}</PRE>
<h4>Parameters</h4>
<P><B><I>var</I></B> - variable of float type. </P>
<h4>Return Value</h4>
<P>Returns new object of SMLVec4f type, which is equal to product of vector and variable. </P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY SMLVec4f <A NAME="operator_divide"><B>operator/</B></A>(float <B><I>var</I></B>) const;</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes and returns quotient of vector and variable <B><I>var</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd[4] = {1, 2, 2, 3};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd), C;<BR>C = A / 2.0f // C = {0.5, 2, 2, 1.5}</PRE>
<h4>Parameters</h4>
<P><B><I>var</I></B> - variable of float type. </P>
<h4>Return Value</h4>
<P>Returns new object of SMLVec4f type, which is quotient of vector and variable. </P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY <A HREF="SMLVec3f.htm#SMLVec3f">SMLVec3f</A>&amp; <A NAME="operator_plusequal"><B>operator+=</B></A>(const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>v</I></B>);</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes sum of two vectors. The result is assigned to the first vector.</P>
<P><I>Example:</I></P>
<PRE>float crd1[4] = {1, 3, 2, 1}, crd2[2] = {2, 2, 2, 2};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd1), B(crd2);<BR>A += B // A = {3, 5, 4, 3}</PRE>
<h4>Parameters</h4>
<P><B><I>v</I></B> - reference to object of SMLVec4f type.</P>
<h4>Return Value</h4>
<P>Returns reference to current object of SMLVec4f type, which is sum of two vectors.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <A NAME="operator_minusequal"><B>operator-=</B></A>(const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>v</I></B>);</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes difference of two vectors. The result is assigned to the first vector.</P>
<P><I>Example:</I></P>
<PRE>float crd1[4] = {1, 3, 2, 1}, crd2[2] = {2, 2, 2, 2};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd1), B(crd2);<BR>A -= B // A = {-1, 1, 0, -1}</PRE>
<h4>Parameters</h4>
<P><B><I>v</I></B> - reference to object of SMLVec4f type.</P>
<h4>Return Value</h4>
<P>Returns reference to current object of SMLVec4f type, which is difference of two vectors.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <A NAME="operator_timesequal"><B>operator*=</B></A>(float <B><I>var</I></B>);</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes product of vector and variable <B><I>var</I></B>. The result is assigned to this vector.</P>
<P><I>Example:</I></P>
<PRE>float crd[4] = {1, 3, 2, 1};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd);<BR>A *= 2.0f // C = {2, 6, 4, 2}</PRE>
<h4>Parameters</h4>
<P><B><I>v</I></B> - reference to object of SMLVec4f type.</P>
<h4>Return Value</h4>
<P>Returns reference to the current object of SMLVec4f type, which is product of vector and variable <B><I>var</I></B> now. </P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY <A HREF="SMLVec3f.htm#SMLVec3f">SMLVec3f</A>&amp; <A NAME="operator_divideequal"><B>operator/=</B></A>(float <B><I>var</I></B>);</P>
<h4>Discussion</h4>
<P>Method is an overloaded operator-function. It computes quotient of vector and variable. The result is assigned to this vector.</P>
<P><I>Example:</I></P>
<PRE>float crd[4] = {1, 3, 2, 1};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd);<BR>A /= 2.0f // C = {0.5, 1.5, 1, 0.5}</PRE>
<h4>Parameters</h4>
<P><B><I>var</I></B> - reference to object of SMLVec3f type.</P>
<h4>Return Value</h4>
<P>Returns reference to the current object of SMLVec3f type, which is quotient of the vector and variable.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY void <B>Set</B>(float <B><I>x</I></B>, float <B><I>y</I></B>, float <B><I>z</I></B>, float <B><I>w</I></B>);</P>
<h4>Discussion</h4>
<P>Method sets coordinates of vector equal to variables <B><I>x, y, z, w</I></B>.</P>
<h4>Parameters</h4>
<P><B><I>x, y, z, w</I></B> - new coordinates of the vector.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY void <A NAME="Add"><B>Add</B></A>(const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>vec1</I></B>, const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>vec2</I></B>);</P>
<h4>Discussion</h4>
<P>Method sets coordinates of vector equal to sum of corresponding coordinates of two vectors <B><I>vec1</I></B> and <B><I>vec2</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd1[4] = {1, 3, 2, 1}, crd2[3] = {2, 2, 2, 2};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd1), B(crd2), C;<BR>C.Add(A, B); // C = {3, 5, 4, 3}</PRE>
<h4>Parameters</h4>
<P><B><I>vec1, vec2</I></B> - vectors to be added .</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY void <A NAME="Sub"><B>Sub</B></A>(const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>vec1</I></B>, const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>vec2</I></B>);</P>
<h4>Discussion</h4>
<P>Method sets coordinates of vector equal to difference of corresponding coordinates of two vectors <B><I>vec1</I></B> and <B><I>vec2</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd1[4] = {1, 3, 2, 1}, crd2[3] = {2, 2, 2, 2};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd1), B(crd2), C;<BR>C.Sub(A, B); // C = {-1, 1, 0, -1}</PRE>
<h4>Parameters</h4>
<P><B><I>vec1, vec2</I></B> - vectors, difference of which is to be computed.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY void <A NAME="Scale"><B>Scale</B></A>(float <B><I>var</I></B>, const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>v</I></B>);</P>
<h4>Discussion</h4>
<P>Method sets coordinates of vector equal to product of variable <B><I>var </I></B>and vector <B><I>v</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float crd[4] = {1, 3, 2, 1};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd1);<BR>A.Scale(2.0f); // A = {2, 6, 4, 2}</PRE>
<h4>Parameters</h4>
<P><B><I>var</I></B> - variable of float type (scale parameter).</P>
<P><B><I>v</I></B> - reference to vector to be scaled. </P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY void <B>Transform</B>(const <A HREF="SMLMatrix4f.htm#SMLMatrix4f">SMLMatrix4f</A>&amp; <B><I>matr</I></B>, const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>vec</I></B>);</P>
<h4>Discussion</h4>
<P>Method transforms coordinates of vector <B><I>vec</I></B> in accordance with matrix of SMLMatrix4f object <B><I>matr</I></B>. It computes product of the matrix and the vector. The transformed vector is a vector of component data of current object.</P>
<h4>Parameters</h4>
<P><B><I>matr</I></B> - reference to object of SMLMatrix4f type, which defines transformation matrix.</P>
<P><B><I>vec</I></B> - reference to vector to be transformed. Object of SMLVec4f type.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY void <A NAME="Transform"><B>Transform</B></A>(const <A HREF="SMLMatrix4f.htm#SMLMatrix4f">SMLMatrix4f</A>&amp; <B><I>matr</I></B>, const <A HREF="SMLVec3f.htm#SMLVec3f">SMLVec3f</A>&amp; <B><I>vec</I></B>);</P>
<h4>Discussion</h4>
<P>Method transforms coordinates of given vector <B><I>vec </I></B>in accordance with component matrix of SMLMatrix4f object <B><I>matr</I></B>. Method computes product of three first columns of the matrix and the vector then to obtained vector it adds the last column of the matrix. Coordinates of new vector are assigned to component vector of SMLVec4f-type object for which this method is called, i.e. the transformed vector is component data of current object.</P>
<h4>Parameters</h4>
<P><B><I>matr</I></B> - reference to object of SMLMatrix4f type, which defines transformation matrix.</P>
<P><B><I>vec</I></B> - reference to vector to be transformed. Object of SMLVec3f type.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="Dot"><B>Dot</B></A>(const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>vec</I></B>) const;</P>
<h4>Discussion</h4>
<P>Method computes scalar product of this vector and vector <B><I>vec</I></B>.</P>
<h4>Parameters</h4>
<P><B><I>vec</I></B> - reference to the second vector of the scalar product.</P>
<P><I>Example:</I></P>
<PRE>float sp, crd1[4] = {1, 3, 2, 1}, crd2[2] = {2, 2, 2, 2};<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(crd1), B(crd2);<BR>sp = A.Dot(B); // sp = 14</PRE>
<h4>Return Value</h4>
<P>Returns scalar product of this vector and vector <B><I>vec</I></B>.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <A NAME="Negate"><B>Negate</B></A>();</P>
<h4>Discussion</h4>
<P>Method replaces this vector with vector <B>(-x, -y, -z, -w)</B>.</P>
<P><I>Example:</I></P>
<PRE><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(1, 3, 2, 1); A.Negate(); // A = {-1, -3, -2, -1}</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns reference to this vector.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="Length"><B>Length</B></A>() const;</P>
<h4>Discussion</h4>
<P>Method computes length of this vector.</P>
<P><I>Example:</I></P>
<PRE>float l;<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(3,4,5,8); l = A.Length();</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns length of this vector.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="LengthSquared"><B>LengthSquared</B></A>() const;</P>
<h4>Discussion</h4>
<P>Method computes length squared of this vector.</P>
<P><I>Example:</I></P>
<PRE>float ls;<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(3,4,5,8); ls = A.LengthSquared();</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns length squared of this vector.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="Distance"><B>Distance</B></A>(const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>vec</I></B>) const;</P>
<h4>Discussion</h4>
<P>Method computes distance between two points. The first point is defined by this vector, the second vector is defined by reference <B><I>vec</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float d;<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(3,4,1,2), B(4,3,2,5);<BR>d = A.Distance(B);</PRE>
<h4>Parameters</h4>
<P><B><I>vec</I></B> - radius-vector of the second point. Reference to object of SMLVec4f type.</P>
<h4>Return Value</h4>
<P>Methods returns distance between two points. </P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="DistanceSquared"><B>DistanceSquared</B></A>(const <A HREF="SMLVec4f.htm#SMLVec4f">SMLVec4f</A>&amp; <B><I>vec</I></B>) const;</P>
<h4>Discussion</h4>
<P>Method computes distance squared between two points. The first point is defined by this vector, the second vector is defined by reference <B><I>vec</I></B>.</P>
<P><I>Example:</I></P>
<PRE>float ds;<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(2,4,2,1), B(4,3,1,1);<BR>ds = A.Distance(B);</PRE>
<h4>Parameters</h4>
<P><B><I>vec</I></B> - radius-vector of the second point. Reference to object of SMLVec4f type.</P>
<h4>Return Value</h4>
<P>Methods returns distance squared between two points.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>

<P>SMLLIBENTRY float <A NAME="Normalize"><B>Normalize</B></A>();</P>
<h4>Discussion</h4>
<P>Method normalizes this vector. If length of the vector is smaller than 1 / FLT_EPSILON, the normalized vector is created in accordance with general rules, i. e. normalized vector is equal to this vector divided on its length. If norm of the vector is greater than 1 / FLT_EPSILON, the method forms unit vector with coordinates {0; 1; 0; 0}.</P>
<P><I>Example:</I></P>
<PRE>float n;<BR><A href="SMLVec4f.htm#SMLVec4f">SMLVec4f</A> A(3,4,2,1);<BR>n = A.Normalize();</PRE>
<h4>Parameters</h4>
<P>No.</P>
<h4>Return Value</h4>
<P>Methods returns value equal to the inverted length of this vector.</P>
<p>[<A href="SMLVec4f.htm#SMLVec4f">top</A>]</p><HR>
</BODY>
</HTML>
